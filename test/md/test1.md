# Задание 4. Сетевая файловая система

Ядро Linux — [монолитное](https://en.wikipedia.org/wiki/Monolithic_kernel). Это означает, что все его части работают в общем адресном пространстве. Однако, это не означает, что для добавления какой-то возможности необходимо полностью перекомпилировать ядро. Новую функциональность можно добавить в виде _модуля ядра_. Такие модули можно легко загружать и выгружать по необходимости прямо во время работы системы.

С помощью модулей можно реализовать свои файловые системы, причём со стороны пользователя такая файловая система ничем не будет отличаться от [ext4](https://en.wikipedia.org/wiki/Ext4) или [NTFS](https://en.wikipedia.org/wiki/NTFS). В этом задании мы с Вами реализуем упрощённый аналог [NFS](https://en.wikipedia.org/wiki/Network_File_System): все файлы будут храниться на удалённом сервере, однако пользователь сможет пользоваться ими точно так же, как и файлами на собственном жёстком диске.

**Мы рекомендуем при выполнении этого домашнего задания использовать отдельную виртуальную машину: любая ошибка может вывести всю систему из строя, и вы можете потерять ваши данные.**

Мы проверили работоспособность всех инструкций для дистрибутива [Ubuntu 20.04 x64](https://releases.ubuntu.com/20.04/) и ядра версии 5.4.0-90. Возможно, при использовании других дистрибутивов, вы столкнётесь с различными ошибками и особенностями, с которыми вам придётся разобраться самостоятельно.

**Выполните задание в ветке `networkfs`**

## Часть 1. Сервер файловой системы

Все файлы и структура директорий хранятся на удалённом сервере. Сервер поддерживает HTTP API, документация к которому доступна [по ссылке](http://nerc.itmo.ru/teaching/os/networkfs/).

Для получения токенов и тестирования вы можете воспользоваться консольной утилитой [curl](https://curl.se).

Сервер поддерживает два типа ответов:

Бинарные данные: набор байт (`char*`), который можно скастить в структуру, указанную в описании ответа. Учтите, что первое поле ответа (первые 8 байт) — код ошибки.

[JSON-объект](https://www.json.org/json-en.html): человекочитаемый ответ. Для его получения необходимо передавать GET-параметр `json`.

Формат JSON предлагается использовать только для отладки, поскольку текущая реализация функции `connect_to_server` работает только с бинарным форматом. Однако, вы можете её доработать и реализовать собственный JSON-парсер.

Для начала работы вам необходимо завести собственный бакет — пространство для хранения файлов, и получить токен для доступа к нему. Это делается следующим запросом:

`$ curl https://nerc.itmo.ru/teaching/os/networkfs/v1/token/issue?json`

`{"status":"SUCCESS","response":"8c6a65c8-5ca6-49d7-a33d-daec00267011"}`

Строка `8c6a65c8-5ca6-49d7-a33d-daec00267011` и является токеном, который необходимо передавать во все последующие запросы. Количество токенов и размер файловой системы не ограничены, однако, мы будем вынуждены ограничить пользователей в случае злоупотребления данной возможностью.

Запускать user-space программы из kernel-space затруднительно, поэтому мы реализовывали для вас собственный HTTP-клиент в виде функции `connect\_to\_server` ([`utils.c:73`](utils.c#L73)):

`int connect\_to\_server(const char *command, int params_count, const char *params[], const char *token, char *output_buf);`

`const char *command` — название метода (`list`, `create`, `read`, `write`, `lookup`, `unlink`, `rmdir`, `link`)

`int params_count` — количество параметров

`const char *params[]` — список параметров — строки вида `<parameter_name>=<value>`

`const char *token` — ваш токен

`char *output_buf` — буфер для сохранения ответа от сервера размером не менее 8 КБ

Функция возвращает 0, если запрос завершён успешно, и код соответствующей ошибки ([utils.c:8](utils.c#L8)) в случае неуспешного HTTP-запроса (если не удалось подключиться к серверу, прочитать ответ или если статус HTTP-ответа не равен 200).