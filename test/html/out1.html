<h1>Задание 4. Сетевая файловая система</h1>
<p>Ядро Linux — <a href='https://en.wikipedia.org/wiki/Monolithic_kernel'>монолитное</a>. Это означает, что все его части работают в общем адресном пространстве. Однако, это не означает, что для добавления какой-то возможности необходимо полностью перекомпилировать ядро. Новую функциональность можно добавить в виде <em>модуля ядра</em>. Такие модули можно легко загружать и выгружать по необходимости прямо во время работы системы.</p>
<p>С помощью модулей можно реализовать свои файловые системы, причём со стороны пользователя такая файловая система ничем не будет отличаться от <a href='https://en.wikipedia.org/wiki/Ext4'>ext4</a> или <a href='https://en.wikipedia.org/wiki/NTFS'>NTFS</a>. В этом задании мы с Вами реализуем упрощённый аналог <a href='https://en.wikipedia.org/wiki/Network_File_System'>NFS</a>: все файлы будут храниться на удалённом сервере, однако пользователь сможет пользоваться ими точно так же, как и файлами на собственном жёстком диске.</p>
<p><strong>Мы рекомендуем при выполнении этого домашнего задания использовать отдельную виртуальную машину: любая ошибка может вывести всю систему из строя, и вы можете потерять ваши данные.</strong></p>
<p>Мы проверили работоспособность всех инструкций для дистрибутива <a href='https://releases.ubuntu.com/20.04/'>Ubuntu 20.04 x64</a> и ядра версии 5.4.0-90. Возможно, при использовании других дистрибутивов, вы столкнётесь с различными ошибками и особенностями, с которыми вам придётся разобраться самостоятельно.</p>
<p><strong>Выполните задание в ветке <code>networkfs</code></strong></p>
<h2>Часть 1. Сервер файловой системы</h2>
<p>Все файлы и структура директорий хранятся на удалённом сервере. Сервер поддерживает HTTP API, документация к которому доступна <a href='http://nerc.itmo.ru/teaching/os/networkfs/'>по ссылке</a>.</p>
<p>Для получения токенов и тестирования вы можете воспользоваться консольной утилитой <a href='https://curl.se'>curl</a>.</p>
<p>Сервер поддерживает два типа ответов:</p>
<p>Бинарные данные: набор байт (<code>char*</code>), который можно скастить в структуру, указанную в описании ответа. Учтите, что первое поле ответа (первые 8 байт) — код ошибки.</p>
<p><a href='https://www.json.org/json-en.html'>JSON-объект</a>: человекочитаемый ответ. Для его получения необходимо передавать GET-параметр <code>json</code>.</p>
<p>Формат JSON предлагается использовать только для отладки, поскольку текущая реализация функции <code>connect<em>to</em>server</code> работает только с бинарным форматом. Однако, вы можете её доработать и реализовать собственный JSON-парсер.</p>
<p>Для начала работы вам необходимо завести собственный бакет — пространство для хранения файлов, и получить токен для доступа к нему. Это делается следующим запросом:</p>
<p><code>$ curl https://nerc.itmo.ru/teaching/os/networkfs/v1/token/issue?json</code></p>
<p><code>{"status":"SUCCESS","response":"8c6a65c8-5ca6-49d7-a33d-daec00267011"}</code></p>
<p>Строка <code>8c6a65c8-5ca6-49d7-a33d-daec00267011</code> и является токеном, который необходимо передавать во все последующие запросы. Количество токенов и размер файловой системы не ограничены, однако, мы будем вынуждены ограничить пользователей в случае злоупотребления данной возможностью.</p>
<p>Запускать user-space программы из kernel-space затруднительно, поэтому мы реализовывали для вас собственный HTTP-клиент в виде функции <code>connect_to_server</code> (<a href='utils.c#L73'><code>utils.c:73</code></a>):</p>
<p><code>int connect_to_server(const char <em>command, int params_count, const char </em>params[], const char <em>token, char </em>output_buf);</code></p>
<p><code>const char *command</code> — название метода (<code>list</code>, <code>create</code>, <code>read</code>, <code>write</code>, <code>lookup</code>, <code>unlink</code>, <code>rmdir</code>, <code>link</code>)</p>
<p><code>int params_count</code> — количество параметров</p>
<p><code>const char *params[]</code> — список параметров — строки вида <code>&lt;parameter_name&gt;=&lt;value&gt;</code></p>
<p><code>const char *token</code> — ваш токен</p>
<p><code>char *output_buf</code> — буфер для сохранения ответа от сервера размером не менее 8 КБ</p>
<p>Функция возвращает 0, если запрос завершён успешно, и код соответствующей ошибки (<a href='utils.c#L8'>utils.c:8</a>) в случае неуспешного HTTP-запроса (если не удалось подключиться к серверу, прочитать ответ или если статус HTTP-ответа не равен 200).</p>
